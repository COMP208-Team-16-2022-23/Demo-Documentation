import{_ as d,a as r,b as l,c as h,d as s,e as t,f as n,g as c,h as o,i as p,j as _,k as m}from"./decision_tree-709a35dd.js";import{_ as u,M as f,p as x,q as b,R as e,t as a,N as g,U as A,a1 as N}from"./framework-efe98465.js";const S="/images/data-analysis/realiability_test.png",y={},C=e("h1",{id:"数据分析",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#数据分析","aria-hidden":"true"},"#"),a(" 数据分析")],-1),k=N('<p>本章将告诉你如何用LCDA进行数据分析，以及我们提供的所有算法的相关信息。</p><ol><li><p>点击上方导航栏中的 <code>Data Analysis</code> 进入数据分析页面。</p></li><li><p>登录后，点击右上角的 <code>NEW ANALYSIS</code> ，这里我们选择数据集，点击 <code>START ANALYSING</code> 开始对数据进行分析。 <img src="'+d+'" alt="data_analysis"><img src="'+r+'" alt="start_analysing"></p></li><li><p>项目页面首先会展示该项目的分析结果 <code>Analysis results</code> 和算法选择区域 <code>Choose algorithm</code> 。</p><p><img src="'+l+'" alt="project_view"></p><p>在算法选择区域，数据分析算法和模型被分为几个大类。这里我们将对鸢尾花数据集应用 KNN分类算法，因此我们点击 <code>ML Classification</code> ，在展开项中选择 <code>K-Nearest Neighbors</code> 。右侧将会显示算法的介绍，可选参数及相应描述。 <img src="'+h+'" alt="knn"> 配置好参数后，在页面末尾的右下角点击 <code>SUBMIT</code> 提交算法和参数。</p></li><li><p>提交算法后，在左侧的分析结果 <code>Analysis results</code> 中能够看到刚刚运行的算法的分析报告。点击报告，即可在右侧查看。 <img src="'+s+'" alt="result_view"></p></li><li><p>报告右上角的 <code>Print</code> 按钮提供了报告的全屏视图和下载。</p></li></ol><h2 id="描述性分析" tabindex="-1"><a class="header-anchor" href="#描述性分析" aria-hidden="true">#</a> 描述性分析</h2><h3 id="正态性分析" tabindex="-1"><a class="header-anchor" href="#正态性分析" aria-hidden="true">#</a> 正态性分析</h3><p>正态性检验用于检验数据是否满足正态分布，一些算法需要数据满足正态分布（如单样本 t 检验，独立样本 t 检验等）。</p><h4 id="输入和输出" tabindex="-1"><a class="header-anchor" href="#输入和输出" aria-hidden="true">#</a> 输入和输出</h4><ul><li>输入：一个或多个定量变量（如 30 名员工这个月的工资）。</li><li>输出：模型检验的结果，数据满足/不满足正态分布。</li></ul><h4 id="案例操作" tabindex="-1"><a class="header-anchor" href="#案例操作" aria-hidden="true">#</a> 案例操作</h4><p><img src="'+t+'" alt="normality_test"></p><h2 id="综合评价" tabindex="-1"><a class="header-anchor" href="#综合评价" aria-hidden="true">#</a> 综合评价</h2><h3 id="critic权重法" tabindex="-1"><a class="header-anchor" href="#critic权重法" aria-hidden="true">#</a> CRITIC权重法</h3><p>CRITIC权重法是一种客观赋权法。其思想在于用两项指标，分别是对比强度和冲突性指标。对比强度使用标准差进行表示，如果数据标准差越大说明波动越大，权重会越高；冲突性使用相关系数进行表示，如果指标之间的相关系数值越大，说明冲突性越小，那么其权重也就越低。对于多指标多对象的综合评价问题，CRITIC法去消除一些相关性较强的指标的影响，减少指标之间信息上的重叠，更有利于得到可信的评价结果。</p><h4 id="输入和输出-1" tabindex="-1"><a class="header-anchor" href="#输入和输出-1" aria-hidden="true">#</a> 输入和输出</h4><p>-输入：至少两项或以上的定量变量（可以做正、负向处理，但是不要做标准化）。</p><p>-输出：输入定量变量对应的权重值。</p><h4 id="案例操作-1" tabindex="-1"><a class="header-anchor" href="#案例操作-1" aria-hidden="true">#</a> 案例操作</h4><p><img src="'+n+'" alt="decision_matrix"></p><h2 id="问卷分析" tabindex="-1"><a class="header-anchor" href="#问卷分析" aria-hidden="true">#</a> 问卷分析</h2><h3 id="信度分析" tabindex="-1"><a class="header-anchor" href="#信度分析" aria-hidden="true">#</a> 信度分析</h3><p>信度分析主要用来考察问卷中量表所测结果的稳定性以及一致性，即用于检验问卷中量表样本是否可靠可信。量表题型就是问题的选项，是分陈述等级进行设置的。比如我们对手机的喜爱从非常喜欢到不喜欢这个程度的变化。在量表里面最出名的就是李克特 5 级量表，在这种量表的选项里面主要是分为&#39;非常同意&#39;、&#39;同意&#39;、&#39;不一定&#39;、&#39;不同意&#39;、&#39;非常不同意&#39;五种回答，分别记为 5、4、3、2、1。</p><h4 id="输入和输出-2" tabindex="-1"><a class="header-anchor" href="#输入和输出-2" aria-hidden="true">#</a> 输入和输出</h4><ul><li>输入：至少两项或以上的定量变量或有序的定类变量，一般要求数据为量表数据。</li><li>输出：收集问卷量表的信度是否可靠。</li></ul><h4 id="案例操作-2" tabindex="-1"><a class="header-anchor" href="#案例操作-2" aria-hidden="true">#</a> 案例操作</h4><p><img src="'+S+'" alt="realiability_test"></p><h2 id="计量经济模型" tabindex="-1"><a class="header-anchor" href="#计量经济模型" aria-hidden="true">#</a> 计量经济模型</h2><h3 id="单位根检验-adf" tabindex="-1"><a class="header-anchor" href="#单位根检验-adf" aria-hidden="true">#</a> 单位根检验（ADF）</h3><p>在使用很多时间序列模型的时候，如 ARMA、ARIMA，都会要求时间序列是平稳的，所以一般在研究一段时间序列的时候，第一步都需要进行平稳性检验，除了用肉眼检测的方法，另外比较常用的严格的统计检验方法就是 ADF 检验，也叫做单位根检验。单位根检验是指检验序列中是否存在单位根，因为存在单位根就是非平稳时间序列了。</p><h4 id="输入和输出-3" tabindex="-1"><a class="header-anchor" href="#输入和输出-3" aria-hidden="true">#</a> 输入和输出</h4><ul><li>输入：１个时间序列数据定量变量</li><li>输出：序列数据在几阶差分时达到平稳</li></ul><h4 id="案例操作-3" tabindex="-1"><a class="header-anchor" href="#案例操作-3" aria-hidden="true">#</a> 案例操作</h4><p><img src="'+c+'" alt="ADF_test"></p><h2 id="医学统计模型" tabindex="-1"><a class="header-anchor" href="#医学统计模型" aria-hidden="true">#</a> 医学统计模型</h2><h3 id="bland-altman法" tabindex="-1"><a class="header-anchor" href="#bland-altman法" aria-hidden="true">#</a> Bland-Altman法</h3><p>Bland-Altman 法是一种可视化进行一致性检验的方法。其原理是一种用 2 种方法结果的差值、均值及 95%一致性(LoA)绘制图形直观的方法，从而得出 2 种方法结果是否具有一致性。</p><h4 id="输入和输出-4" tabindex="-1"><a class="header-anchor" href="#输入和输出-4" aria-hidden="true">#</a> 输入和输出</h4><ul><li>输入：代表两种方法的两个定量变量。</li><li>输出：Bland-Altman 图以及方法是否具有一致性。</li></ul><h4 id="案例操作-4" tabindex="-1"><a class="header-anchor" href="#案例操作-4" aria-hidden="true">#</a> 案例操作</h4><p><img src="'+o+'" alt="Bland_Altman"></p><h2 id="机器学习分类" tabindex="-1"><a class="header-anchor" href="#机器学习分类" aria-hidden="true">#</a> 机器学习分类</h2><h3 id="k近邻" tabindex="-1"><a class="header-anchor" href="#k近邻" aria-hidden="true">#</a> K近邻</h3><p>K近邻(KNN)分类器是有监督学习中普遍使用的分类器之一，将观察值的分类判定为离它最近的k个观察值中所占比例最大的分类。</p><h4 id="输入和输出-5" tabindex="-1"><a class="header-anchor" href="#输入和输出-5" aria-hidden="true">#</a> 输入和输出</h4><ul><li>输入：自变量 X 为 1 个或 1 个以上的定类或定量变量，因变量 Y 为一个定类变量。</li><li>输出：模型的分类结果和模型分类的评价效果。</li></ul><h4 id="案例操作-5" tabindex="-1"><a class="header-anchor" href="#案例操作-5" aria-hidden="true">#</a> 案例操作</h4><p><img src="'+p+'" alt="k_nn"></p><h3 id="svm" tabindex="-1"><a class="header-anchor" href="#svm" aria-hidden="true">#</a> SVM</h3><p>支持向量机（SVM）是一类按监督学习方式对数据进行二元分类的广义线性分类器，其决策边界是对学习样本求解的最大边距超平面。</p><h4 id="输入和输出-6" tabindex="-1"><a class="header-anchor" href="#输入和输出-6" aria-hidden="true">#</a> 输入和输出</h4><ul><li>输入：自变量 X 为 1 个或 1 个以上的定类或定量变量，因变量 Y 为一个定类变量。</li><li>输出：模型的分类结果和模型分类的评价效果。</li></ul><h4 id="案例操作-6" tabindex="-1"><a class="header-anchor" href="#案例操作-6" aria-hidden="true">#</a> 案例操作</h4><p><img src="'+_+'" alt="svm"></p><h3 id="决策树" tabindex="-1"><a class="header-anchor" href="#决策树" aria-hidden="true">#</a> 决策树</h3><p>决策树是一个类似流程图的结构，其中每个内部节点代表对一个属性的判定，每个分支代表判定的结果，每个叶子节点代表一个类别标签（在计算所有属性后做出的决定）</p><h4 id="输入和输出-7" tabindex="-1"><a class="header-anchor" href="#输入和输出-7" aria-hidden="true">#</a> 输入和输出</h4><ul><li>输入： 自变量 X 为 1 个或 1 个以上的定类或定量变量，因变量 Y 为一个定类变量。</li><li>输出：模型的分类结果和模型分类的评价效果。</li></ul><h4 id="参数选项" tabindex="-1"><a class="header-anchor" href="#参数选项" aria-hidden="true">#</a> 参数选项</h4><ul><li>数据洗牌： 是否对数据进行随机洗牌</li><li>训练比例： 训练数据与整个数据集的比例</li><li>交叉验证： 从原始样本中随机划分出的大小相等的子样本的数量。每个子样本将被保留作为测试模型的验证数据，而其余的子样本将被用作训练数据。</li><li>准则： 衡量分割质量的函数。支持的标准有： <ul><li>gini：用于衡量gini不纯度</li><li>信息熵：用于衡量Shannon信息增长。</li></ul></li><li>分割器： 用于在每个节点选择分割的策略。支持的策略有 <ul><li>最佳：选择最佳分割</li><li>随机：选择最佳随机分割</li></ul></li><li>Min Samples Split： 拆分一个内部节点所需的最小样本数： <ul><li>如果是int，那么考虑<code>min_samples_split</code>作为最小数量。</li><li>如果是float，那么<code>min_samples_split</code>是一个分数，<code>ceil(min_samples_split * n_samples)</code>是每个分裂的最小样本数。</li></ul></li><li>Min Samples Leaf： 在一个叶子节点上所需的最小样本数。任何深度的分割点只有在左右两个分支中至少留下<code>min_samples_leaf</code>训练样本时才会被考虑。这可能有平滑模型的效果，特别是在回归中。 <ul><li>如果是int，那么考虑<code>min_samples_leaf</code>作为最小数量。</li><li>如果是float，那么<code>min_samples_leaf</code>是一个分数，<code>ceil(min_samples_leaf * n_samples)</code>是每个节点的最小样本数。...... 版本变更：： 0.18 增加了分数的浮点值。</li></ul></li><li>最大深度： 决策树的最大深度。如果没有，那么节点会被展开，直到所有的叶子都是纯的，或者直到所有的叶子都包含小于<code>min_samples_split</code>的样本。</li><li>最大叶子结点： 用<code>max_leaf_nodes</code>以最佳优先方式生长一棵树。最佳节点被定义为相对减少的不纯度。如果没有，则叶子节点的数量不限。</li></ul><h4 id="例子" tabindex="-1"><a class="header-anchor" href="#例子" aria-hidden="true">#</a> 例子</h4><p><img src="'+m+'" alt="decision_tree"></p>',59);function I(M,R){const i=f("RouterLink");return x(),b("div",null,[C,e("p",null,[a("数据分析帮助你在"),g(i,{to:"/zh/guide/data-processing.html"},{default:A(()=>[a("数据处理")]),_:1}),a("的基础上分析你的数据。数据分析提供各种算法和模型，用于经济学、医学、社会科学和机器学习等。")]),k])}const L=u(y,[["render",I],["__file","data-analysis.html.vue"]]);export{L as default};
